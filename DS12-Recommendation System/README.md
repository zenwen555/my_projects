# Recommendation System

>Знакомимся с рекомендательными системами, алгоритмами их построения и реализуем базовую систему рекомендаций фильмов

Для построения системы рекомендательной системы воспользуемся данными платформы **Kaggle** - *TMDB 5000 Movie Dataset*, где собранна информация о 5000 фильмов из пользовательской базы *TMDb*\
Данные [tmdb_5000_credits.csv](https://www.kaggle.com/datasets/tmdb/tmdb-movie-metadata?select=tmdb_5000_credits.csv) содержат `id` каждого фильма, имена главных и второстепенных актеров, имена режиссера, редактора, композитора, сценариста и т.д.\
Данные [tmdb_5000_movies.csv](https://www.kaggle.com/datasets/tmdb/tmdb-movie-metadata?select=tmdb_5000_movies.csv) содержат `id` каждого фильма, бюджет, жанр, ключевые слова или теги, язык, оригинальное название, страну и дату выпуска, оценку фильма пользователями, количество голосов и т.д.

### Task 1
Объедини данные о фильмах из двух файлов [tmdb_5000_movies](../datasets/tmdb_5000_credits.csv) и 
[tmdb_5000_credits](../datasets/tmdb_5000_movies.csv), используя только фильмы, вышедшие в прокат\
Выведем количество, оставшихся после фильтрации, фильмов

### Task 2
>Самый простой способ - рекомендовать фильмы с лучшим рейтингом

Посчитаем рейтинг для каждого фильма и сохраним его в колонку `simple_score`\
Для этого используем функцию *WR* текущей рейтенговой системі **IMDb** - `weighted_rating`, где в качестве параметра $m$ возмём  95-й квантиль количества голосов\
Выведем топ-5 фильмов

### Task 3
>**Content Based Filtering** - это контентная фильтрация, рекомендательная система предлагает похожие фильмы, основываясь на ранее просмотренные и учитывая жанр, режиссера, описание фильма и т.п.

Построим алгоритм рекомендаций по описанию фильма\
Предварительно необходима преоброботка текста:
- заменим Nan на `''` - пустой символ
- используя параметр `stop_words` из **TfidfVectorizer**, удалим английские стоп-слова
- преобразуем описания фильмов в матрицу функций *Tf-Idf*, используя для **TfidfVectorizer** параметры по умолчанию

Выведем размер матрицы *Tf-Idf*

### Task 4
Используя косинусное расстояние, необходимо вычислиить показатель сходства между описаниями фильмов, в случаи с матрицей *Tf-Idf* расчитаем скалярное произведение с помощью **linear_kernel**, и сохраним его в `cosine_sim`\
Выведи размер получившейся матрицы `cosine_sim`

### Task 5
Создадим функцию **get_recommendations** для поиска фильмов похожих на заданный по описанию. На входе функции
- `movies_dataset` - датасет со всеми фильмами
- `title` - название заданного фильма
- `cosine_sim` - матрица косинусных расстояний между описаниями фильмов
- `top_k` - количество схожих фильмов для поиска

На выходе - названия фильмов, похожих по описанию на заданный\
Найдём топ-5 для фильма `title='Saving Private Ryan'`

### Task 6
>**Collaborative Filtering** - коллаборативная фильтрация, учитывает интересы других, похожих пользователей, т.е. если одному из пользователей понравился фильм, то другому, с похожими интересами, он тоже понравиться

Построим алгоритм коллаборативной фильтрации на основе оценок пользователей [ratings](../datasets/ratings.csv), где имеются `id` пользователя, `id` фильма и его рейтинг\
Для обучения модели оценки по рейтингу используем алгоритм **SVD** библиотеки **surprise**\
Выведем средние значения `RMSE`, `MAE` на кросс-валидации
