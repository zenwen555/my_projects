# Введение в SQL

>Работа с базой данных *SQL* компании из сферы образования, у которой есть своя платформа, где учащиеся могут проверить правильность выполненых заданий, посмотреть результат работ, получить обратную связь \
В таблице `checker` хранятся записи кто, когда, какие задания сдал \
Компания создала на платформе страницу с лентой новостей, доступ к ней по логинам есть у всех учащиеся, записи о посещениях страницы хранятся в таблице `pageviews` \
Расчитывают, что при просмотре ленты новостей у учащихся появится больше мотивации, они будут раньше приступать к выполнению заданий, что даст возможность им сделать больше попыток и опробовать разные подходы для выполнения работ, быстрее справляться с заданиями \
Проверим, подтвердилась ли эта идея в эксперименте, когда одним учащимся была показана лента новостей, а другим – нет \
База данных [здесь](datasets/checking-logs.sqlite)

### Task 1
>Отсортируем, отфильтруем и приобразуем данные из базы

Для начала поместим базу данных, с которой будем работать в подкаталог **data** в корневом каталоге
1. Используя библиотеку *sqlite3*, создадим соединение с базой данных 
2. Выведем информацию о таблице `pageviews`
3. Выведем первые 10 строк таблицы `pageviews`
4. Получим подтаблицу с помощью *одного* запроса, в котором:
    - используюем столбцы `uid` и `datetime`;
    - не рассматриваем данные администраторов, а только пользователей `user_*`;
    - сортируем по `uid` в порядке возрастания;
    - столбец индекса — это `datetime`;
    - данные `datetime` преобразуем в индекс *DatetimeIndex*;
    - имя датафрейма — **pageviews**
5. В конце закроим соединение с базой данных

### Task 2
1. Используя библиотеку *sqlite3*, создадим соединение с базой данных 
2. Выведем информацию о таблице `checker`
3. Выведем первые 10 строк таблицы `checker`
4. Используя только *один* запрос, посчитаем строки удовлетворяющие таким условиям:
    - узнаем количество пользователей из таблицы `pageviews`, которым в таблице `checker`, соответствуют следующие условия:
        - статус выполнения задания `status` должен быть `'ready'`, логи со статусом `checking` - не учитываем;
        - анализируем `numTrials = 1`, это коммит, с информацией когда учащийся приступил к выполнению данного задания;
        - нас интересуют только задания активные в период проведения эксперимента: `laba04`, `laba04s`, `laba05`, `laba06`, `laba06s`, `project1`
    - Сохраним данные в датафрейме **checkers** с одной ячейкой в столбце `cnt`
5. В конце закроим соединение с базой данных

### Task 3
>В этом задании мы создадим витрину данных, объединяя несколько таблиц, для дальнейшего анализа этих данных

Нас интересуют следующие данные: даты первых коммитов заданий, дата первого посещения ленты новостей и др.
1. Используя библиотеку *sqlite3*, создадим соединение с базой данных
2. Используя только *один* запрос, объединим таблицы `pageviews` и `checker` в таблицу **datamart**, удовлетворящую следующим условиям:
    - Таблица должна иметь столбцы - `uid`, `labname`, `first_commit_ts`, `first_view_ts`, где
        - `first_commit_ts` - это новое имя столбца `timestamp` из таблицы `checker`, который содержит дату первого коммита каждого задания каждого учащегося
        - `first_view_ts` -  это новое имя столбца `datetime` из таблицы `pageviews`, который содержит дату первого посещения учащимся ленты новостей
    - Так же рассматриваем только готовые задания `status = 'ready'`
    - Так же рассматриваем только первые коммиты `numTrials = 1`
    - Так же нас интересуют только задания: `laba04`, `laba04s`, `laba05`, `laba06`, `laba06s`, `project1`
    - Так же нас интересуют только учащиеся `uid = user_*`
    - `first_commit_ts` и `first_view_ts` нужно распарсить как *datetime64[ns]*
3. Создадим два датафрейма **test** и **control**, с помощью методов библиотеки **Pandas**
    - в `test` включаем учащихся, у которых есть значения в `first_view_ts`, т.е. кто посещал ленту новостей
    - в `control` включаем учащихся, у которых нет значения в `first_view_ts`, т.е. кто не посещал ленту новостей
    - отсутствующие значения `first_view_ts` в `control` заменим на среднее значение `first_view_ts` из `test`, в дальнейшем будем использовать его для анализа
    - сохраним **test** и **control** в базе данных
4. Закроим соединение с базой данных

### Task 4
>Теперь проанализируем, влияет ли просмотр ленты новостей на сроки сдачи работ

Сроки сдачи соответствующих заданий загружены в таблице **deadlines** \
Нашей метрикой будет  - разница между датой начала работы над заданием и датой его сдачи
1. Используя библиотеку *sqlite3*, создадим соединение с базой данных
2. Выведем информацию о таблице `test`
3. Выведем первые 10 строк таблицы `test`
4. Найдём и выведем минимальное значение `delta` и имя пользователя с этим минимальным периодом, используя *один* запрос \
Для этого:
    - объединим данные своей таблицы с данными таблицы `deadlines`
    - переведём период времи в часы
    - задание `project1` учитывать не будем, т.к. у него длинный срок сдачи
    - в датафрейме **df_min** сохраним значение `delta` и соответствующий `uid`
5. Сделаем тоже самое для максимального значения `delta`, используя *один* запрос и название датафрейма - **df_max**
6. Сделаем тоже самое для среднего значения `delta`, используя *один* запрос, название датафрейма - **df_avg** и в нём будет отсутствовать столбец `uid`
7. Теперь проверим верно ли, что у учащихся, просматривающих ленту новостей, срок сдачи заданий меньше \
 Рассчитаем для этого коэффициент корреляции между количеством посещений ленты новостей и средним значением `delta` для каждого учащегося
    - С помощью *одного* запрос, создадим таблицу со столбцами: `uid`, `avg_diff`, `pageviews`, где
        - `uid` - это `uid` учащихся из таблицы `test`;
        - `avg_diff` - среднее значение `delta`, т.е. период между датой первого коммита и датой сдачи для каждого задания каждого учащегося;
        - `pageviews` — количество посещений ленты новостей каждым учащимся;
        - задание `project1` учитывать не будем;
        - сохраним данные в датафрейме **views_diff** 
    - Чтоб вычислить коэффициент корреляции между количеством посещений ленты новостей и значением `delta`, воспользуемся методом *corr()* библиотеки **Pandas**
8. Закроим соединение с базой данных

### Task 5
>Проведём подобие **А/В тестирования**

Тестирование для баз данных `test` - с учащимися, что посещали ленту новостей и `control` - с теми, которые её не просматривали \
Для этого вычислим два средних значения `delta` до первого посещения ленты новостей и после, для тестовой и контрольной групп, т.к. учащиеся контрольной группы не посещали ленту новостей, то мы будем использовать среднее значение даты первого посещения в таблице `test`, ранее мы его вычислили и сохранили в таблице `control`
1. Используя библиотеку *sqlite3*, создадим соединение с базой данных
2. Используя данные таблиц `test` и `control` и только *один* запрос создадим два датафрейма **test_results** и **control_results**:
    - новые датафреймы содержат 2 столбца `times` и `avg_diff`
    - новые датафреймы содержат 2 строки, соответственно столбец `times` имет значения `before` и `after`
    - столбец `avg_diff` содержит среднее значение `delta`, учитывающее всех учащихся за период времени до первого посещения ленты новостей и после, соответственно
    - в анализе учавствуют учащиеся у которых есть значения и `before`, и `after`
    - задание `project1` не учитываем 
3. Закроим соединение с базой данных
4. Наконец, можем сделать вывод, повлияло ли наличие ленты новостей на мотивацию учащихся \
Если значение `delta` в тестовой группе значительно отличается перед первым посещением учащимися ленты новостей и после посещения и подобного не происходит в контрольной группе - значит мы можем рекомендовать компании распространить идею создания ленты новостей на платформе для всех обучающихся
